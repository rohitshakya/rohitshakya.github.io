<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Buffer Cache Simulation | Rohit Shakya</title> <meta name="generator" content="Jekyll v4.4.1" /> <meta property="og:title" content="Buffer Cache Simulation" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Buffer Cache Simulation" /> <meta property="og:description" content="Buffer Cache Simulation" /> <link rel="canonical" href="http://localhost:4000/projects/buffer-cache-simulation" /> <meta property="og:url" content="http://localhost:4000/projects/buffer-cache-simulation" /> <meta property="og:site_name" content="Rohit Shakya" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2019-04-09T00:00:00+05:30" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Buffer Cache Simulation" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2019-04-09T00:00:00+05:30","datePublished":"2019-04-09T00:00:00+05:30","description":"Buffer Cache Simulation","headline":"Buffer Cache Simulation","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/projects/buffer-cache-simulation"},"url":"http://localhost:4000/projects/buffer-cache-simulation"}</script> <!-- End Jekyll SEO tag --> <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"> <link rel="stylesheet" href="/css/main.css"> </head> <body> <header class="site-header"> <nav class="navbar navbar-default"> <div class="container-fluid"> <!-- Brand and toggle get grouped for better mobile display --> <div class="navbar-header"> <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/">Rohit Shakya</a> </div> <!-- Collect the nav links, forms, and other content for toggling --> <div class="collapse navbar-collapse " id="bs-example-navbar-collapse-1"> <ul class="nav navbar-nav navbar-right"> <li><a class="navbar-brand" style="font-size: 1.2em" href="/projects/">Projects</a></li> <!-- <li><a class="navbar-brand" style="font-size: 1.2em" href="/skills/">Skills</a></li> --> <li><a class="navbar-brand" style="font-size: 1.2em" href="/resume/">Resume</a></li> </ul> </div><!-- /.navbar-collapse --> </div><!-- /.container-fluid --> </nav> </header> <div class="container"> <div class="wrapper"> <div class="row"> <div class="col-md-2"></div> <div class="col-md-8"> <article class="post" itemscope itemtype="http://schema.org/BlogPosting"> <header class="post-header"> <h1 class="post-title" itemprop="name headline">Buffer Cache Simulation</h1> <h4 style="text-decoration-color: grey" itemprop="name headline">Tech Involved - C++, makefile, shell script</h4> <h4 style="text-decoration-color: grey" itemprop="name headline">Checkout the github repo - <a href="https://github.com/rohitshakya" target="_blank" rel="noopener noreferrer"> github.com/rohitshakya </a> </h4> </header> <div class="post-content" itemprop="articleBody"> <br> <h1 id="buffer-cache-simulation">Buffer Cache Simulation</h1> <p>A simple buffer cache implementation for simulation of <code class="language-plaintext highlighter-rouge">getblk</code> and <code class="language-plaintext highlighter-rouge">brelse</code> algorithms.</p> <h2 id="overview">Overview</h2> <p>In this implementation, the main program act as <code class="language-plaintext highlighter-rouge">kernel</code> and manipulates the buffer cache, while user input acts as coming and going <code class="language-plaintext highlighter-rouge">processes</code>. User controls which block to get and release. User can also manipulate buffer status. This gives us complete control over the simulation. Also we can view the buffer cache, freelist, buffer list, and sleeping processes at all times.</p> <p>This is a single-process synchronous program, so there is no added complexity of managing threads.</p> <h2 id="how-to-run">How to Run</h2> <ul> <li>Compile using <code class="language-plaintext highlighter-rouge">make</code></li> <li>Then you can simply run the executable <code class="language-plaintext highlighter-rouge">./bufcache</code></li> <li>Alternatively, use <code class="language-plaintext highlighter-rouge">make run</code></li> </ul> <h2 id="how-to-test">How to test</h2> <ul> <li>Run tests and see scenarios by executing test script <code class="language-plaintext highlighter-rouge">./test.sh</code></li> <li>Alternatively, use <code class="language-plaintext highlighter-rouge">make test</code></li> </ul> <h2 id="problem-statement">Problem Statement</h2> <p>Buffer cache simulation. The idea was to simulate <code class="language-plaintext highlighter-rouge">getblk</code> and <code class="language-plaintext highlighter-rouge">brelse</code> algorithms that handle the allocation and release of buffers to processes. The key requirement was to be able to visualize all 5 scenarios of <code class="language-plaintext highlighter-rouge">getblk</code> and clearly identify the working of <code class="language-plaintext highlighter-rouge">getblk</code> in all of those scenarios.</p> <h2 id="suggested-solution">Suggested Solution</h2> <p>We want a simulation slow enough to analyse the working details of <code class="language-plaintext highlighter-rouge">getblk</code>. Several implementations are possible. Let us glance over them.</p> <h3 id="threads">threads</h3> <p>Threads over processes because all of the children (processes) need to work on the same data structure instance (buffer cache).</p> <p>Because threads can easily run into race conditions when writing to the data structure, locks need to be implemented.</p> <p>Once threads and locks are in place we can think about <code class="language-plaintext highlighter-rouge">getblk</code> implementation.</p> <p>We now need to show all 5 cases of <code class="language-plaintext highlighter-rouge">getblk</code> so we need to control how different threads are scheduled. For this we need a scheduler. Either we can implement our own (which is overkill for just a simulation), or choose the system scheduler, and forcing it to choose certain process by <code class="language-plaintext highlighter-rouge">sleep</code>ing others.</p> <p>This results in an intricate mechanism of all the threads working with system scheduler. We have little control over the actual buffers and their status. If we want to manipulate some buffers to test something, we will need to spin up another thread at runtime to handle the buffer status.</p> <p>Preliminary tests show unreliability in threads and their execution order because we cannot exactly predict how the system scheduler will schedule them.</p> <h3 id="client-server-architecture">client server architecture</h3> <p>Server acts as kernel, and only server manipulates the buffer cache directly.</p> <p>Clients (<code class="language-plaintext highlighter-rouge">processes</code>) can ask server (<code class="language-plaintext highlighter-rouge">kernel</code>) to allocate them a buffer (<code class="language-plaintext highlighter-rouge">getblk</code>) and inform them when they relinquish the buffer, so kernel can release the buffer (<code class="language-plaintext highlighter-rouge">brelse</code>).</p> <p>Server controls how these client requests are scheduled. The actual buffer cache implementation will reside with the server. Because, server (<code class="language-plaintext highlighter-rouge">kernel</code>) needs to be able to accept requests from multiple clients (<code class="language-plaintext highlighter-rouge">processses</code>), it’ll spin up a new handler process for each new client.</p> <p>This brings us back to our original problem. Now these multiple processes need to communicate and somehow share the memory region for manipulating buffer cache. Implementation complexity will be no better than the previous <code class="language-plaintext highlighter-rouge">threads</code> approach.</p> <h3 id="user-driven-simulation">User driven simulation</h3> <p>Let the main program act as <code class="language-plaintext highlighter-rouge">kernel</code> and manipulate the buffer cache, while user input acts as coming and going <code class="language-plaintext highlighter-rouge">processes</code>. User controls which block to get and release. User can also manipulate buffer status.</p> <p>This gives us complete control over the simulation. Also we can view the buffer cache, freelist, buffer list, and sleeping processes at all times.</p> <p>Because this will be a single-process synchronous program, there is no added complexity of managing threads. We can focus on <code class="language-plaintext highlighter-rouge">getblk</code> and <code class="language-plaintext highlighter-rouge">buffer cache</code>.</p> <p>This is the chosen approach for this project.</p> <h2 id="programming-language-used">Programming Language Used</h2> <p><code class="language-plaintext highlighter-rouge">C</code> is the chosen language. Because we are implementing buffer cache, which is a lower level algorithm, it needs to be fast and <code class="language-plaintext highlighter-rouge">C</code> provides the fastest system calls. Also the fact that actual unix system is written in <code class="language-plaintext highlighter-rouge">C</code> made it an easy choice.</p> <h2 id="aos-concepts-implemented">AOS Concepts Implemented</h2> <p>The chosen implementation type is kept simple. So it does not use any complex constructs of AOS.</p> <ol> <li>Forks/Threads - not required</li> <li>Locking unlocking mechanism - not required</li> <li>Signals - not required</li> </ol> <h2 id="getblk-cases-handled">Getblk cases Handled</h2> <p>All 5 cases of <code class="language-plaintext highlighter-rouge">getblk</code> have been handled.</p> <h3 id="how-the-request-for-a-block-is-being-captured">How the request for a block is being captured</h3> <p>User input determines which block to <code class="language-plaintext highlighter-rouge">get</code> and <code class="language-plaintext highlighter-rouge">release</code></p> <h3 id="delayed-write">Delayed write</h3> <p>User manually sets a <code class="language-plaintext highlighter-rouge">block status</code> to <code class="language-plaintext highlighter-rouge">delayed write</code>. Then when the <code class="language-plaintext highlighter-rouge">getblk</code> algorithm sees this <code class="language-plaintext highlighter-rouge">delayed write</code> marked buffer, it starts a dummy async write to disk, and moves on the next free list buffer.</p> <h2 id="supported-commands">Supported Commands</h2> <p>Directly from the help section of the program.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight">
    <pre class="highlight"><code>help


buf 
	Display the status of all the buffers.
hash
	Display all the Hash Queues.
free
	Display free list
wait
	Display waiting Queue
exit
	To exit the simulation

getblk &lt;blockNumber&gt;

	Take the blockNumber from the user, execute getblk(n)

brelse &lt;blockNumber&gt;

	Take the blockNumber from the user, execute brelse() 

set &lt;blockNumber&gt; &lt;statusCode&gt; 

	Set the status of the buffer to status code

	B : Buffer Busy
	V : Buffer Data is Valid
	D : Buffer is marked delayed write
	K : Kernet is reading/writing buffer to disk
	W : Buffer is awaited by some other process
	O : Buffer Data is OLD

reset &lt;blockNumber&gt; &lt;statusCode&gt; 

	Reset the status of the buffer to status code

	B : Buffer Busy
	V : Buffer Data is Valid
	D : Buffer is marked delayed write
	K : Kernet is reading/writing buffer to disk
	W : Buffer is awaited by some other process
	O : Buffer Data is OLD

</code></pre></div></div> </div> </article> <div class="row"> <ul class="pager"> <li> <a class="next" href="/projects/crm-projects">&laquo; Multiple CRM Projects </a></li> <li> <a class="previous" href="/projects/vivavolt-in"> Viva Volt &raquo;</a> </li> </ul> <ul class="pager"> <li> <a class="next" href="#" onclick="disqus();return false;">Show Comments &dArr;</a> </li> </ul> </div> </div> <div class="col-md-2"></div> <div class="row"> <div id="disqus_thread"></div> <script defer> var disqus_loaded = false; function disqus() { if (!disqus_loaded) { disqus_loaded = true; var d = document, s = d.createElement('script'); s.src = '//rohitshakya-github-io.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); } } </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> </div> </div> </div> </div> <footer> <div class="container"> <div class="row p20"> <div class="col-md-12 text-center mt25"> © 2025 <strong>Rohit Shakya</strong> </div> </div> </div> </footer> <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script> <script src="/js/bootstrap.min.js"></script> </body> </html>